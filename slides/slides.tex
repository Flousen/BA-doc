\section{QR-Zerlegung}
\begin{frame}
	\frametitle{QR-Zerlegung}
%	\vspace{-2cm}
	\begin{itemize}
		\item $ A = QR $\\
		\scalebox{.8}{\input{images/QRsheme.tex}}
		\item $ Ax = b $ lösen mit QR: $\quad QRx=b \quad \Longleftrightarrow \quad Rx=Q^Tb $
		\item Kern operation im QR-Verfahren (Berechnung von Eigenwerten)
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Householder-Transformation}
	\vspace{-1cm}
	\begin{align*}
		H = I - 2 \dfrac{vv^T}{v^Tv}
	\end{align*}
	\centering
	\scalebox{.8}{\input{images/hh.tex}}

\end{frame}

\begin{frame}
	\frametitle{Householder-Transformation}
	\vspace{-1cm}
	\begin{itemize}
	\item Householder Vektor berechnen\\
		\begin{itemize}
			\item Ansatz $ Hx = \alpha e_1 $
			\item Normieren $ v_1 = 1 $
			\item $ \tau = \dfrac{2}{v^Tv} \quad \Longrightarrow \quad H = I - 2 \dfrac{vv^T}{v^Tv} = I - \tau vv^T$
		\end{itemize}
		
%		$\alpha = -1 \cdot \text{sign}(x_1) \|x\|_2$\\
%		$\tau = \dfrac{\alpha - x_1}{\alpha}$\\
%		$v=\dfrac{x - \alpha e_1}{x_1 - \alpha}$ 

	\item  Householder-Transformation anwenden
		\begin{align*} 
		H A =(I - \tau vv^T) A= A - \tau (vv^T )A = A - \tau v(v^TA)
		\end{align*}
	\end{itemize}
\end{frame}

\input{images/QRHH.tex}

\begin{frame}
\frametitle{Benchmark}
	\begin{itemize}
		\item Peak performance \\
		25,6 GFLOPS auf dem Testsystem mit i5-3470-CPU
		\item Aufwand QR mittels Householder $A \in \mathbb{R}^{m \times n},~~ m \ge n$
		\begin{align*}
			\#\text{QR} &= n\cdot\left( \frac{23}{6}+m+\frac{n}{2} + n\cdot\left(m-\frac{n}{3}\right) + \frac{5}{6} + n\cdot\left(\frac{1}{2} + m-\frac{n}{3}\right) \right) = \mathcal{O}(n^2m)
		\end{align*}
		\item Flops
		\begin{align*}
			\text{FLOPS} = \dfrac{\text{Aufwand}}{\Delta t}
		\end{align*}
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Ungeblockte QR}
	\centering
	\scalebox{.85}{
		\includegraphics[width=\textwidth]{images/unblk}
	}
\end{frame}



\begin{frame}
	\frametitle{Mehrere Householder-Transformationen anwenden}	
	\vspace{-1cm}	
		\begin{itemize}
			\item Ansatz\\
			\vspace{0.3cm}
			$\hat{H} = H_1H_2...H_k = I - VTV^T \quad \text{mit}\quad H_i = I - \tau_i v_iv_i^T $
			\vspace{0.3cm}
			\item Householder-Transformationen anwenden\\
			\vspace{0.3cm}
			$ C \leftarrow \hat{H} C = C - V T V^T C \quad $
			
		\end{itemize}

		\vspace{-3cm}
		\hspace{9.5cm}
		\centering
		\input{images/partitionOFAslide.tex}
\end{frame}

\input{images/partofAani.tex}

\begin{frame}
\frametitle{Verschiedene Blockgrößen}
		\centering
	\scalebox{.85}{
		\includegraphics[width=\textwidth]{images/blkbs}
	}
\end{frame}

\begin{frame}
\frametitle{Geblockte QR - Blocksizes}
	\centering
	\scalebox{.85}{
		\includegraphics[width=\textwidth]{images/both}
	}
\end{frame}

\begin{frame}
\frametitle{Fazit}
\centering
\begin{itemize}
	\item Ungeblockter Algorithmus erreicht nicht die \textit{peak performance}.
	\item Eigener ungeblockte Algorithmus ist etwa 5\% schneller als MKL.
	\item Geblockte Algorithmus erreicht fast die \textit{peak performance}.
	\item Der geblockte Algorithmus \textit{dgeqrf} der MKL ist etwas schneller. Der selbst implementierten Algorithmus erreicht bis zu 94\% die Performance der MKL.
	\item Der geblockte Algorithmus ist um den Faktor 3 schneller als der ungeblockte Algorithmus.
\end{itemize}
\end{frame}




